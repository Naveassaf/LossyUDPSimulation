/*
Source File: Channel: main.c
Functionality: This source file implements the channel module in its entirety. This module is incharge of routing data to and from the Sender and Receiver ports, 
			counting the total transactions and fliping bits sent from the Sender to the Receiver with a command-line provided probability of n/2^16 per bit (iid).
			Once the transactions are finished, the channel prints the statistics of the connections to the console.
*/



/*oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO*/

#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#define PACKET_SIZE 8
#define SUMMARY_FROM_SERVER 100
#define CHANNEL_ADDRESS_STR "127.0.0.1"
#define MAX_RAND 32767
#define IP_LEN 16
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>
#pragma comment(lib, "ws2_32.lib")

/*oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO*/

int n;
unsigned int seed;
SOCKET s_socket;
SOCKADDR_IN clientSendService;
SOCKADDR_IN serverSendService;
SOCKADDR_IN ChannelRecvService;
int channelPort;
char serverIP[IP_LEN];
int serverPort;
int bitsFlipped;
int framesPassed;

/*oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO*/

/*
Name: factorialForBinom()
Functionality: Given a double x (always a whole number, but for simplicity passed and returns a double), this funtion returns its factorial.
*/
double factorialForBinom(double x)
{
	if(x <= 1)
	{
		return 1;
	}
	else
	{
		return factorialForBinom(x - 1)*x;
	}
}

/*
Name: binomRand()
Functionality: Given an int m, double p and int k, this function returns the binomial distribution probabilty: P(X = k), where X ~ Binomial(m, p).
				It is used inorder to save rand() number generations when deciding how many bits to flip.
*/
double binomRand(int m, double p , int k)
{
	double fact_m, fact_k, fact_m_k, result;
	fact_m = factorialForBinom((double)m);
	fact_k = factorialForBinom((double)k);
	fact_m_k = factorialForBinom((double)(m - k));
	result = pow(p, (double)k)*pow(1 - p, (double)(m - k))*fact_m/(fact_m_k*fact_k);
	return result;
}

/*
Name: createProbabilityArray()
Functionality: Given a pointer to an array of doubles, this function alters the array such that its values are ranges 
				of a uniform distribution which represent probabilities of a Binomial(m, p) distribution. For example
				when X~Bin(m, p), Y~Uniform(0,1), P(X = k) = P( arr[k-1] < Y < arr[k]).
*/
void createProbabilityArray(int m, double p, double *arr)
{
	double accumulate = 0, temp = 0;
	for (int i = 0; i < m; i++)
	{
		temp = binomRand(m, p, i);
		arr[i] = temp + accumulate;
		accumulate += temp;
	}
}

/*
Name: flipBits()
Functionality: Using the array generated by the functions above, this function randomly (with probability of n/2^16 per bit) flips bits within the string char_arr[].
*/
void flipBits(char* char_arr, double p)
{
	int shiftsToGo;
	int flipped_count = 0;
	int i = 0;
	double r = rand() / (double)MAX_RAND;
	int bitsToFlip = 0;
	double probabilities[8*PACKET_SIZE]; //8*PACKET_SIZE = number of bits per packet
	int flippedAlready[8 * PACKET_SIZE] = { 0 };
	unsigned char mask = 128, temp;
	
	createProbabilityArray(8 * PACKET_SIZE, p, probabilities);
	for (bitsToFlip = 0; bitsToFlip < 8 * PACKET_SIZE; bitsToFlip++)
	{
		if (r < probabilities[bitsToFlip])
			break;
	}

	for (int j = 0; j < bitsToFlip; j++)
	{
		temp = rand();
		if (temp == MAX_RAND)
			temp -= 1;
		shiftsToGo = (int)(temp*((8 * PACKET_SIZE -j)/ ((double)MAX_RAND)));
		i = 0;
		while (1)
		{
			if (shiftsToGo == 0 && flippedAlready[i] == 0)
			{
				flippedAlready[i] = 1;

				break;
			}
			if (flippedAlready[i] == 0)
			{
				shiftsToGo--;
			}
			i++;
		}
	}

	for (int k = 0; k < 8 * PACKET_SIZE; k++)
	{
		if (flippedAlready[k] == 1)
		{
			bitsFlipped++;
			char_arr[k / 8] ^= mask >> (k % 8);
		}
	}
	
}

/*
Name: arrivedFromServer()
Functionality: Help function used by the channel to determin if the message received on its port is from the Sender or Receiver. Returns 1 if from Receiver
				and 0 if from the Sender
*/
int arrivedFromServer(SOCKADDR_IN source)
{
	if (source.sin_addr.s_addr == serverSendService.sin_addr.s_addr && source.sin_port == serverSendService.sin_port)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

/*
Name: RecvDataThread()
Functionality: Thread in charge of receiving messages on the port which the channel binded. Once a message is received, the function
				decides the source of the message, insuring to send to client if arrived from server and visa versa. If the message
				if from the Sender, this function also calls the flip_bits method to randomly flip bits with a probability of n/2^16
*/
static DWORD RecvDataThread(void)
{
	int firstFromClient = 1;
	SOCKADDR_IN lastReceived;
	int iResult;
	char RecvBuf[SUMMARY_FROM_SERVER];
	int lastReceivedSize = sizeof(lastReceived);
	srand(seed);

	while (1)
	{
		// Receive message
		iResult = recvfrom(s_socket, RecvBuf, SUMMARY_FROM_SERVER, 0, &lastReceived, &lastReceivedSize);
		Sleep(1);

		if (firstFromClient && arrivedFromServer(lastReceived) == 0)
		{
			clientSendService = lastReceived;
			firstFromClient = 0;
		}
		if (arrivedFromServer(lastReceived))
		{
			iResult = sendto(s_socket, RecvBuf, SUMMARY_FROM_SERVER, 0, &clientSendService, sizeof(clientSendService));
			return 0;
		}
		else
		{
			flipBits(RecvBuf,((double)n) / pow(2.0, 16.0));
			iResult = sendto(s_socket, RecvBuf, PACKET_SIZE, 0, &serverSendService, sizeof(serverSendService));
			framesPassed++;
		}
		if (iResult == SOCKET_ERROR)
		{
			fprintf(stderr, "Socket error while trying to write data to socket\n");
			return 0x555;
		}
	}

	return 0;
}


/*oOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoOoO*/
/*
Name: MainChannel()
Functionality:The thread function which implemets the main thread of the channel module. Similarily to the MainClient and MainServer, this function is in charge of
				setting up the WSA lib and initializing and binding all necessary sockets and ports. Once these are all set up, the funtion starts the send and 
				receive threads and waits for them to terminate before closing the sockets it must.
*/
void MainChannel()
{
	HANDLE hThread[1];

	// Initialize Winsock.
	WSADATA wsaData; //Create a WSADATA object called wsaData.
					 //The WSADATA structure contains information about the Windows Sockets implementation.

					 //Call WSAStartup and check for errors.
	int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != NO_ERROR)
		fprintf(stderr, "Error at WSAStartup()\n");

	//Call the socket function and return its value to the m_socket variable. 
	// For this application, use the Internet address family, streaming sockets, and the TCP/IP protocol.

	// Create a socket.
	s_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	// Check for errors to ensure that the socket is a valid socket.
	if (s_socket == INVALID_SOCKET) {
		fprintf(stderr, "Error at socket(): %ld\n", WSAGetLastError());
		WSACleanup();
		return;
	}


	//Create a sockaddr_in object clientSendService and set  values.
	serverSendService.sin_family = AF_INET;
	serverSendService.sin_addr.s_addr = inet_addr(serverIP); //Setting the IP address to connect to
	serverSendService.sin_port = htons(serverPort); //Setting the port to connect to.


	ChannelRecvService.sin_family = AF_INET;
	ChannelRecvService.sin_addr.s_addr = inet_addr(CHANNEL_ADDRESS_STR); 
	ChannelRecvService.sin_port = htons(channelPort); //Setting the port to connect to.


	iResult = bind(s_socket, (SOCKADDR *)&ChannelRecvService, sizeof(ChannelRecvService));
	if (iResult != 0)
	{
		fprintf(stderr, "Bind failed\n");
		return;
	}

	
	hThread[0] = CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)RecvDataThread,
		NULL,
		0,
		NULL
	);
	

	WaitForSingleObject(hThread[0], INFINITE);

	TerminateThread(hThread[0], 0x555);
	

	CloseHandle(hThread[0]);
	

	closesocket(s_socket);


	WSACleanup();

	return;
}

/*
Name: main()
Functionality: The actual main function of the channel module. This function initializes the global variables to be used by all threads. It
				then calls the MainCHannel() function described above and prints the transaction results one the MainChannel() function finishes its work.
*/
int main(int argc, char *argv[])
{
	char clientIP[IP_LEN];
	bitsFlipped = 0;
	framesPassed = 0;
	channelPort = atoi(argv[1]);
	strncpy(serverIP, argv[2], IP_LEN);
	serverPort = atoi(argv[3]);
	n = atoi(argv[4]);
	seed = (unsigned int)atoi(argv[5]);
	MainChannel();
	inet_ntop(AF_INET, &(clientSendService.sin_addr), clientIP, IP_LEN);
	fprintf(stderr, "sender: %s\nreceiver: %s\n%d bytes, flipped %d bits\n", clientIP, serverIP, 8*framesPassed, bitsFlipped);
}
